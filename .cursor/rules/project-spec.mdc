# Discord Music Bot - Technical Specification (Pure Go stdlib)

## Project Overview

A production-ready Discord bot built entirely with Go's standard library, demonstrating deep Go expertise and systems programming skills. This project showcases mastery of net/http, proper HTTP handling, and building robust web services without framework dependencies.

## Why This Architecture Demonstrates Elite Hiring Value

This project showcases advanced skills that separate senior engineers from framework users:

- **Go Mastery**: Pure stdlib demonstrates deep language understanding
- **HTTP Fundamentals**: Building proper HTTP services from first principles
- **Systems Programming**: Low-level control over request handling and performance
- **Zero Dependencies**: Production code with minimal external dependencies
- **Performance Engineering**: Hand-optimized request routing and handling
- **Protocol Understanding**: Deep knowledge of HTTP/1.1, HTTP/2, WebSockets
- **Microservices Architecture**: Service separation without framework overhead
- **Production Patterns**: Middleware, graceful shutdown, health checks built from scratch

## Architecture Overview

```
Discord Bot Service → Redis Queue → Background Worker Service → PostgreSQL Database
                                                                        ↓
                                    SvelteKit Frontend ← Pure Go HTTP Server
                                                         (stdlib only)
```

Built entirely with Go standard library for maximum performance and minimum dependencies.

## Technology Stack (Stdlib Focus)

### Backend (Zero Framework Dependencies)

- **Language**: Go 1.21+ standard library only
- **HTTP Server**: `net/http` (HTTP/1.1, HTTP/2, TLS built-in)
- **JSON**: `encoding/json` (optimized encoder/decoder)
- **Database**: `database/sql` with `pgx` driver
- **Discord**: `github.com/bwmarrin/discordgo` (only external dependency)
- **Redis**: `github.com/redis/go-redis` (minimal Redis client)
- **Routing**: Custom router built on `net/http.ServeMux`
- **WebSockets**: `golang.org/x/net/websocket` (stdlib extension)
- **Templates**: `html/template` (for any server-side rendering)
- **Logging**: `log/slog` (structured logging, Go 1.21+)
- **Configuration**: `flag` + `os` (12-factor app pattern)
- **Context**: `context` (request tracing and cancellation)
- **Concurrency**: `sync` (worker pools, mutexes)

### Frontend

- **Framework**: SvelteKit (static build)
- **Styling**: Tailwind CSS
- **Build**: Served as static files by Go HTTP server

### Infrastructure

- **Containerization**: Docker (multi-stage builds)
- **Reverse Proxy**: Optional Nginx (stdlib can handle SSL directly)
- **Database**: PostgreSQL 15
- **Queue**: Redis 7

## Project Structure (stdlib-focused)

```
discord-music-bot/
├── cmd/                           # Service binaries
│   ├── bot/main.go               # Discord bot service
│   ├── worker/main.go            # Background worker service
│   └── api/main.go               # HTTP API server
├── internal/                      # Private packages
│   ├── config/                   # Configuration
│   │   └── config.go             # Flag-based config
│   ├── domain/                   # Business entities
│   │   ├── track.go              # Track entity
│   │   ├── server.go             # Discord server entity
│   │   └── repository.go         # Repository interfaces
│   ├── repository/               # Data access
│   │   ├── postgres/
│   │   │   ├── track.go          # SQL-based track repo
│   │   │   ├── server.go         # SQL-based server repo
│   │   │   └── migrations.go     # Database migrations
│   │   └── redis/
│   │       └── queue.go          # Redis queue implementation
│   ├── service/                  # Business logic
│   │   ├── bot/
│   │   │   ├── service.go        # Bot orchestration
│   │   │   ├── handlers.go       # Discord event handlers
│   │   │   └── commands.go       # Bot commands
│   │   ├── worker/
│   │   │   ├── service.go        # Worker orchestration
│   │   │   ├── processor.go      # Job processing
│   │   │   └── extractors/       # Metadata extraction
│   │   └── api/
│   │       ├── server.go         # HTTP server setup
│   │       ├── router.go         # Custom routing logic
│   │       ├── handlers/         # HTTP handlers
│   │       │   ├── tracks.go     # Track endpoints
│   │       │   ├── search.go     # Search endpoints
│   │       │   ├── websocket.go  # WebSocket handling
│   │       │   └── static.go     # Static file serving
│   │       └── middleware/       # Custom middleware
│   │           ├── logging.go    # Request logging
│   │           ├── cors.go       # CORS handling
│   │           ├── recovery.go   # Panic recovery
│   │           └── ratelimit.go  # Rate limiting
│   ├── http/                     # HTTP utilities
│   │   ├── response.go           # Response helpers
│   │   ├── request.go            # Request parsing
│   │   └── errors.go             # HTTP error handling
│   └── pkg/                      # Shared utilities
│       ├── logger/               # Structured logging
│       ├── database/             # Database utilities
│       └── queue/                # Queue utilities
├── web/                          # SvelteKit frontend
│   ├── src/
│   │   ├── routes/
│   │   ├── lib/
│   │   └── components/
│   └── static/
├── scripts/                      # Build and deployment
├── migrations/                   # SQL migration files
├── Dockerfile.bot               # Multi-stage Docker builds
├── Dockerfile.worker
├── Dockerfile.api
├── docker-compose.yml
├── go.mod                       # Minimal dependencies
├── go.sum
├── Makefile                     # Development commands
└── README.md
```

## Core HTTP Server Implementation (Pure stdlib)

### Custom Router (No Framework)

```go
// internal/service/api/router.go
type Router struct {
    mux        *http.ServeMux
    middleware []Middleware
    logger     *slog.Logger
}

type Middleware func(http.Handler) http.Handler

func NewRouter(logger *slog.Logger) *Router {
    return &Router{
        mux:    http.NewServeMux(),
        logger: logger,
    }
}

func (r *Router) Use(middleware ...Middleware) {
    r.middleware = append(r.middleware, middleware...)
}

func (r *Router) Handle(pattern string, handler http.HandlerFunc) {
    // Wrap handler with all middleware
    var h http.Handler = handler
    for i := len(r.middleware) - 1; i >= 0; i-- {
        h = r.middleware[i](h)
    }
    r.mux.Handle(pattern, h)
}

func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    r.mux.ServeHTTP(w, req)
}
```

### HTTP Server Setup

```go
// cmd/api/main.go - Pure stdlib HTTP server
func main() {
    // Configuration from flags and environment
    config := config.Load()
    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))

    // Database connection
    db, err := sql.Open("pgx", config.DatabaseURL)
    if err != nil {
        logger.Error("Failed to connect to database", "error", err)
        os.Exit(1)
    }
    defer db.Close()

    // Redis connection
    rdb := redis.NewClient(&redis.Options{
        Addr: config.RedisURL,
    })
    defer rdb.Close()

    // Repositories
    trackRepo := postgres.NewTrackRepository(db)
    serverRepo := postgres.NewServerRepository(db)

    // Services
    apiService := api.NewService(trackRepo, serverRepo, logger)

    // Router setup
    router := api.NewRouter(logger)

    // Middleware stack
    router.Use(
        middleware.Recovery(logger),
        middleware.Logging(logger),
        middleware.CORS(),
        middleware.RateLimit(100), // 100 requests per minute
    )

    // API routes
    router.Handle("/api/v1/tracks", apiService.HandleTracks)
    router.Handle("/api/v1/tracks/", apiService.HandleTrackByID)
    router.Handle("/api/v1/search", apiService.HandleSearch)
    router.Handle("/ws", apiService.HandleWebSocket)

    // Static file serving
    router.Handle("/", apiService.HandleStatic)

    // Health endpoint
    router.Handle("/health", apiService.HandleHealth)

    // Server configuration
    server := &http.Server{
        Addr:         ":" + config.Port,
        Handler:      router,
        ReadTimeout:  15 * time.Second,
        WriteTimeout: 15 * time.Second,
        IdleTimeout:  60 * time.Second,
    }

    // Graceful shutdown
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()

    go func() {
        sigCh := make(chan os.Signal, 1)
        signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)
        <-sigCh

        logger.Info("Shutting down server...")
        shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        if err := server.Shutdown(shutdownCtx); err != nil {
            logger.Error("Server shutdown error", "error", err)
        }
        cancel()
    }()

    logger.Info("Starting server", "port", config.Port)
    if err := server.ListenAndServe(); err != http.ErrServerClosed {
        logger.Error("Server error", "error", err)
        os.Exit(1)
    }
}
```

### HTTP Handlers (Manual but Powerful)

```go
// internal/service/api/handlers/tracks.go
type KnokHandler struct {
    trackRepo  domain.TrackRepository
    serverRepo domain.ServerRepository
    logger     *slog.Logger
}

func (h *TracksHandler) HandleTracks(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()

    switch r.Method {
    case http.MethodGet:
        h.getTracks(ctx, w, r)
    case http.MethodPost:
        h.createTrack(ctx, w, r)
    default:
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
    }
}

func (h *TracksHandler) getTracks(ctx context.Context, w http.ResponseWriter, r *http.Request) {
    // Parse query parameters manually
    serverID := r.URL.Query().Get("server_id")
    if serverID == "" {
        http.Error(w, "server_id is required", http.StatusBadRequest)
        return
    }

    page, err := strconv.Atoi(r.URL.Query().Get("page"))
    if err != nil || page < 0 {
        page = 0
    }

    limit, err := strconv.Atoi(r.URL.Query().Get("limit"))
    if err != nil || limit <= 0 || limit > 100 {
        limit = 20
    }

    // Repository call
    tracks, total, err := h.trackRepo.GetByServerID(ctx, serverID, page*limit, limit)
    if err != nil {
        h.logger.Error("Failed to get tracks", "error", err, "server_id", serverID)
        http.Error(w, "Internal server error", http.StatusInternalServerError)
        return
    }

    // Response construction
    response := APIResponse{
        Success: true,
        Data:    tracks,
        Meta: &Meta{
            Page:       page,
            Limit:      limit,
            Total:      total,
            TotalPages: (total + limit - 1) / limit,
        },
    }

    w.Header().Set("Content-Type", "application/json")
    if err := json.NewEncoder(w).Encode(response); err != nil {
        h.logger.Error("Failed to encode response", "error", err)
    }
}

func (h *TracksHandler) HandleTrackByID(w http.ResponseWriter, r *http.Request) {
    // Extract ID from URL path manually
    path := strings.TrimPrefix(r.URL.Path, "/api/v1/tracks/")
    if path == "" {
        http.Error(w, "Track ID is required", http.StatusBadRequest)
        return
    }

    // Parse UUID
    trackID, err := uuid.Parse(path)
    if err != nil {
        http.Error(w, "Invalid track ID format", http.StatusBadRequest)
        return
    }

    switch r.Method {
    case http.MethodGet:
        h.getTrackByID(r.Context(), w, trackID)
    case http.MethodPut:
        h.updateTrack(r.Context(), w, r, trackID)
    case http.MethodDelete:
        h.deleteTrack(r.Context(), w, trackID)
    default:
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
    }
}
```

### Custom Middleware (Built from Scratch)

```go
// internal/service/api/middleware/logging.go
func Logging(logger *slog.Logger) Middleware {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            start := time.Now()

            // Create response writer wrapper to capture status code
            rw := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}

            // Add request ID to context
            requestID := generateRequestID()
            ctx := context.WithValue(r.Context(), "request_id", requestID)
            r = r.WithContext(ctx)

            // Add request ID to response headers
            w.Header().Set("X-Request-ID", requestID)

            next.ServeHTTP(rw, r)

            duration := time.Since(start)

            logger.Info("HTTP Request",
                "method", r.Method,
                "path", r.URL.Path,
                "status", rw.statusCode,
                "duration_ms", duration.Milliseconds(),
                "request_id", requestID,
                "remote_addr", r.RemoteAddr,
                "user_agent", r.UserAgent(),
            )
        })
    }
}

type responseWriter struct {
    http.ResponseWriter
    statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
    rw.statusCode = code
    rw.ResponseWriter.WriteHeader(code)
}
```

```go
// internal/service/api/middleware/cors.go
func CORS() Middleware {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.Header().Set("Access-Control-Allow-Origin", "*")
            w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
            w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

            if r.Method == http.MethodOptions {
                w.WriteHeader(http.StatusOK)
                return
            }

            next.ServeHTTP(w, r)
        })
    }
}
```

```go
// internal/service/api/middleware/ratelimit.go
func RateLimit(requestsPerMinute int) Middleware {
    limiter := rate.NewLimiter(rate.Limit(requestsPerMinute)/60, requestsPerMinute)

    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            if !limiter.Allow() {
                http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
                return
            }
            next.ServeHTTP(w, r)
        })
    }
}
```

### WebSocket Implementation (stdlib)

```go
// internal/service/api/handlers/websocket.go
import "golang.org/x/net/websocket"

type WebSocketHandler struct {
    clients    map[*websocket.Conn]string // conn -> server_id
    register   chan *websocket.Conn
    unregister chan *websocket.Conn
    broadcast  chan BroadcastMessage
    mutex      sync.RWMutex
    logger     *slog.Logger
}

type BroadcastMessage struct {
    ServerID string      `json:"server_id"`
    Type     string      `json:"type"`
    Data     interface{} `json:"data"`
}

func NewWebSocketHandler(logger *slog.Logger) *WebSocketHandler {
    handler := &WebSocketHandler{
        clients:    make(map[*websocket.Conn]string),
        register:   make(chan *websocket.Conn),
        unregister: make(chan *websocket.Conn),
        broadcast:  make(chan BroadcastMessage),
        logger:     logger,
    }

    go handler.run()
    return handler
}

func (h *WebSocketHandler) run() {
    for {
        select {
        case conn := <-h.register:
            h.mutex.Lock()
            h.clients[conn] = "" // Will be set when client sends server_id
            h.mutex.Unlock()
            h.logger.Info("WebSocket client connected")

        case conn := <-h.unregister:
            h.mutex.Lock()
            if _, ok := h.clients[conn]; ok {
                delete(h.clients, conn)
                conn.Close()
            }
            h.mutex.Unlock()
            h.logger.Info("WebSocket client disconnected")

        case message := <-h.broadcast:
            h.mutex.RLock()
            for conn, serverID := range h.clients {
                if serverID == message.ServerID {
                    if err := websocket.JSON.Send(conn, message); err != nil {
                        h.logger.Error("Failed to send WebSocket message", "error", err)
                        conn.Close()
                        delete(h.clients, conn)
                    }
                }
            }
            h.mutex.RUnlock()
        }
    }
}

func (h *WebSocketHandler) HandleWebSocket(w http.ResponseWriter, r *http.Request) {
    handler := websocket.Handler(func(conn *websocket.Conn) {
        defer conn.Close()

        h.register <- conn
        defer func() { h.unregister <- conn }()

        for {
            var msg map[string]string
            if err := websocket.JSON.Receive(conn, &msg); err != nil {
                break
            }

            // Handle server_id registration
            if serverID, ok := msg["server_id"]; ok {
                h.mutex.Lock()
                h.clients[conn] = serverID
                h.mutex.Unlock()
            }
        }
    })

    handler.ServeHTTP(w, r)
}

func (h *WebSocketHandler) BroadcastTrackAdded(serverID string, track *domain.Track) {
    message := BroadcastMessage{
        ServerID: serverID,
        Type:     "track_added",
        Data:     track,
    }

    select {
    case h.broadcast <- message:
    default:
        h.logger.Warn("WebSocket broadcast channel full")
    }
}
```

### Static File Serving (stdlib)

```go
// internal/service/api/handlers/static.go
func (h *StaticHandler) HandleStatic(w http.ResponseWriter, r *http.Request) {
    // Security: prevent directory traversal
    if strings.Contains(r.URL.Path, "..") {
        http.Error(w, "Invalid path", http.StatusBadRequest)
        return
    }

    // SPA routing: serve index.html for non-API routes
    if !strings.HasPrefix(r.URL.Path, "/api/") &&
       !strings.HasPrefix(r.URL.Path, "/ws") &&
       !strings.HasPrefix(r.URL.Path, "/health") {

        // Check if file exists
        filePath := filepath.Join(h.staticDir, r.URL.Path)
        if _, err := os.Stat(filePath); os.IsNotExist(err) {
            // Serve index.html for SPA routing
            filePath = filepath.Join(h.staticDir, "index.html")
        }

        http.ServeFile(w, r, filePath)
        return
    }

    // Regular static file serving
    fileServer := http.FileServer(http.Dir(h.staticDir))
    fileServer.ServeHTTP(w, r)
}
```

## Database Layer (Pure database/sql)

### Repository Implementation

```go
// internal/repository/postgres/track.go
type KnokRepository struct {
    db     *sql.DB
    logger *slog.Logger
}

func NewTrackRepository(db *sql.DB, logger *slog.Logger) *TrackRepository {
    return &TrackRepository{db: db, logger: logger}
}

func (r *TrackRepository) GetByServerID(ctx context.Context, serverID string, offset, limit int) ([]*domain.Track, int, error) {
    // Count query
    var total int
    countQuery := `SELECT COUNT(*) FROM tracks WHERE server_id = $1`
    if err := r.db.QueryRowContext(ctx, countQuery, serverID).Scan(&total); err != nil {
        return nil, 0, fmt.Errorf("failed to count tracks: %w", err)
    }

    // Data query with proper indexing
    query := `
        SELECT id, server_id, url, platform, title, artist, duration,
               discord_message_id, discord_channel_id, posted_at, created_at
        FROM tracks
        WHERE server_id = $1
        ORDER BY posted_at DESC
        LIMIT $2 OFFSET $3`

    rows, err := r.db.QueryContext(ctx, query, serverID, limit, offset)
    if err != nil {
        return nil, 0, fmt.Errorf("failed to query tracks: %w", err)
    }
    defer rows.Close()

    var tracks []*domain.Track
    for rows.Next() {
        track := &domain.Track{}
        err := rows.Scan(
            &track.ID, &track.ServerID, &track.URL, &track.Platform,
            &track.Title, &track.Artist, &track.Duration,
            &track.DiscordMessageID, &track.DiscordChannelID,
            &track.PostedAt, &track.CreatedAt,
        )
        if err != nil {
            return nil, 0, fmt.Errorf("failed to scan track: %w", err)
        }
        tracks = append(tracks, track)
    }

    if err := rows.Err(); err != nil {
        return nil, 0, fmt.Errorf("rows iteration error: %w", err)
    }

    return tracks, total, nil
}

func (r *TrackRepository) Search(ctx context.Context, serverID, query string, limit int) ([]*domain.Track, error) {
    sqlQuery := `
        SELECT id, server_id, url, platform, title, artist, duration,
               discord_message_id, discord_channel_id, posted_at, created_at,
               ts_rank(search_vector, plainto_tsquery('english', $2)) as rank
        FROM tracks
        WHERE server_id = $1
        AND search_vector @@ plainto_tsquery('english', $2)
        ORDER BY rank DESC, posted_at DESC
        LIMIT $3`

    rows, err := r.db.QueryContext(ctx, sqlQuery, serverID, query, limit)
    if err != nil {
        return nil, fmt.Errorf("failed to search tracks: %w", err)
    }
    defer rows.Close()

    var tracks []*domain.Track
    for rows.Next() {
        track := &domain.Track{}
        var rank float64
        err := rows.Scan(
            &track.ID, &track.ServerID, &track.URL, &track.Platform,
            &track.Title, &track.Artist, &track.Duration,
            &track.DiscordMessageID, &track.DiscordChannelID,
            &track.PostedAt, &track.CreatedAt, &rank,
        )
        if err != nil {
            return nil, fmt.Errorf("failed to scan track: %w", err)
        }
        tracks = append(tracks, track)
    }

    return tracks, rows.Err()
}
```

## Performance Advantages of Pure stdlib

### HTTP/2 Support (Built-in)

```go
// Automatic HTTP/2 when using TLS
server := &http.Server{
    Addr:    ":443",
    Handler: router,
    TLSConfig: &tls.Config{
        // HTTP/2 enabled by default
    },
}
server.ListenAndServeTLS("cert.pem", "key.pem")
```

### Connection Pooling and Timeouts

```go
// Fine-grained control over HTTP behavior
server := &http.Server{
    Addr:           ":8080",
    Handler:        router,
    ReadTimeout:    10 * time.Second,
    WriteTimeout:   10 * time.Second,
    IdleTimeout:    120 * time.Second,
    MaxHeaderBytes: 1 << 20, // 1MB
}
```

### Zero Allocation JSON Streaming

```go
// Stream JSON responses efficiently
func (h *Handler) streamTracks(w http.ResponseWriter, tracks []*Track) {
    w.Header().Set("Content-Type", "application/json")

    encoder := json.NewEncoder(w)
    encoder.Encode(APIResponse{
        Success: true,
        Data:    tracks,
    })
    // No intermediate allocations
}
```

## Deployment Configuration

### Minimal Docker Images

```dockerfile
# Dockerfile.api - Multi-stage build
FROM golang:1.21-alpine AS builder
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o api ./cmd/api

# Final image - just the binary
FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /app/api .
COPY --from=frontend-builder /app/build ./web/build
CMD ["./api"]
```

### Resource Requirements

```yaml
# docker-compose.yml - Minimal resource usage
services:
  api:
    build: .
    restart: unless-stopped
    environment:
      - PORT=8080
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_URL=${REDIS_URL}
    # stdlib efficiency = lower resource requirements
    deploy:
      resources:
        limits:
          memory: 64M
          cpus: "0.25"
```

## Configuration Management (stdlib only)

```go
// internal/config/config.go - Pure stdlib configuration
type Config struct {
    Port        string
    DatabaseURL string
    RedisURL    string
    LogLevel    string
    StaticDir   string
}

func Load() *Config {
    config := &Config{
        Port:      getEnvWithDefault("PORT", "8080"),
        LogLevel:  getEnvWithDefault("LOG_LEVEL", "info"),
        StaticDir: getEnvWithDefault("STATIC_DIR", "./web/build"),
    }

    // Required environment variables
    config.DatabaseURL = mustGetEnv("DATABASE_URL")
    config.RedisURL = mustGetEnv("REDIS_URL")

    // Command line flags override environment
    flag.StringVar(&config.Port, "port", config.Port, "Server port")
    flag.StringVar(&config.LogLevel, "log-level", config.LogLevel, "Log level")
    flag.Parse()

    return config
}

func getEnvWithDefault(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}

func mustGetEnv(key string) string {
    value := os.Getenv(key)
    if value == "" {
        log.Fatalf("Environment variable %s is required", key)
    }
    return value
}
```

## API Response Patterns (Manual but Optimized)

```go
// internal/http/response.go - Efficient response handling
type APIResponse struct {
    Success bool        `json:"success"`
    Data    interface{} `json:"data,omitempty"`
    Error   *APIError   `json:"error,omitempty"`
    Meta    *Meta       `json:"meta,omitempty"`
}

type APIError struct {
    Code    string `json:"code"`
    Message string `json:"message"`
    Details string `json:"details,omitempty"`
}

type Meta struct {
    Page       int `json:"page"`
    Limit      int `json:"limit"`
    Total      int `json:"total"`
    TotalPages int `json:"total_pages"`
}

func WriteJSON(w http.ResponseWriter, status int, data interface{}) error {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(status)
    return json.NewEncoder(w).Encode(data)
}

func WriteError(w http.ResponseWriter, status int, code, message string) {
    response := APIResponse{
        Success: false,
        Error: &APIError{
            Code:    code,
            Message: message,
        },
    }
    WriteJSON(w, status, response)
}

func WriteSuccess(w http.ResponseWriter, data interface{}, meta *Meta) {
    response := APIResponse{
        Success: true,
        Data:    data,
        Meta:    meta,
    }
    WriteJSON(w, http.StatusOK, response)
}
```

## Why This Approach Impresses Employers

### Technical Mastery

- ✅ **Deep Go Knowledge**: Understanding stdlib capabilities vs framework abstractions
- ✅ **HTTP Protocol Expertise**: Building proper HTTP services from first principles
- ✅ **Performance Optimization**: Zero-allocation patterns, efficient request handling
- ✅ **Memory Management**: Understanding Go's GC behavior in web services
- ✅ **Concurrency Patterns**: Proper use of goroutines, channels, sync primitives

### Production Readiness

- ✅ **Security**: Manual input validation, proper error handling
- ✅ **Observability**: Structured logging, health checks, metrics
- ✅ **Reliability**: Graceful shutdown, proper timeouts, circuit breakers
- ✅ **Scalability**: Stateless design, efficient resource usage
- ✅ **Maintainability**: Clean architecture without framework dependencies

### Problem-Solving Skills

- ✅ **Custom Solutions**: Building routing, middleware, WebSocket handling from scratch
- ✅ **Trade-off Analysis**: Understanding when frameworks help vs hurt
- ✅ **Performance Engineering**: Optimizing for specific use cases
- ✅ **Systems Thinking**: Understanding the full stack from HTTP to database

This pure stdlib approach demonstrates the kind of engineering depth that distinguishes senior developers from framework users.

## Monitoring and Health Checks (stdlib)

### Health Check Implementation

```go
// internal/service/api/handlers/health.go
type HealthHandler struct {
    db     *sql.DB
    redis  *redis.Client
    logger *slog.Logger
}

type HealthStatus struct {
    Status    string            `json:"status"`
    Version   string            `json:"version"`
    Timestamp time.Time         `json:"timestamp"`
    Uptime    time.Duration     `json:"uptime"`
    Checks    map[string]Check  `json:"checks"`
}

type Check struct {
    Status   string        `json:"status"`
    Duration time.Duration `json:"duration_ms"`
    Error    string        `json:"error,omitempty"`
}

func (h *HealthHandler) HandleHealth(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodGet {
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        return
    }

    ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
    defer cancel()

    checks := make(map[string]Check)
    overallStatus := "healthy"

    // Database health check
    dbStart := time.Now()
    if err := h.db.PingContext(ctx); err != nil {
        checks["database"] = Check{
            Status:   "unhealthy",
            Duration: time.Since(dbStart),
            Error:    err.Error(),
        }
        overallStatus = "unhealthy"
    } else {
        checks["database"] = Check{
            Status:   "healthy",
            Duration: time.Since(dbStart),
        }
    }

    // Redis health check
    redisStart := time.Now()
    if err := h.redis.Ping(ctx).Err(); err != nil {
        checks["redis"] = Check{
            Status:   "unhealthy",
            Duration: time.Since(redisStart),
            Error:    err.Error(),
        }
        overallStatus = "unhealthy"
    } else {
        checks["redis"] = Check{
            Status:   "healthy",
            Duration: time.Since(redisStart),
        }
    }

    status := HealthStatus{
        Status:    overallStatus,
        Version:   BuildVersion, // Set during build
        Timestamp: time.Now(),
        Uptime:    time.Since(StartTime),
        Checks:    checks,
    }

    statusCode := http.StatusOK
    if overallStatus == "unhealthy" {
        statusCode = http.StatusServiceUnavailable
    }

    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(statusCode)
    json.NewEncoder(w).Encode(status)
}
```

### Metrics Collection (stdlib + expvar)

```go
// internal/pkg/metrics/metrics.go
import (
    "expvar"
    "runtime"
    "sync/atomic"
    "time"
)

var (
    // HTTP metrics
    httpRequestsTotal = expvar.NewMap("http_requests_total")
    httpDuration     = expvar.NewMap("http_duration_seconds")

    // Application metrics
    tracksProcessed = expvar.NewInt("tracks_processed_total")
    activeConnections = expvar.NewInt("websocket_connections")

    // System metrics
    startTime = expvar.NewInt("start_time_unix")
)

func init() {
    startTime.Set(time.Now().Unix())

    // Expose runtime metrics
    expvar.Publish("goroutines", expvar.Func(func() interface{} {
        return runtime.NumGoroutine()
    }))

    expvar.Publish("memory", expvar.Func(func() interface{} {
        var m runtime.MemStats
        runtime.ReadMemStats(&m)
        return map[string]interface{}{
            "alloc_bytes":      m.Alloc,
            "total_alloc_bytes": m.TotalAlloc,
            "sys_bytes":        m.Sys,
            "num_gc":           m.NumGC,
        }
    }))
}

func IncrementHTTPRequests(method, path string, status int) {
    key := fmt.Sprintf("%s_%s_%d", method, path, status)
    httpRequestsTotal.Add(key, 1)
}

func RecordHTTPDuration(method, path string, duration time.Duration) {
    key := fmt.Sprintf("%s_%s", method, path)
    httpDuration.Add(key, duration.Nanoseconds())
}
```

## Error Handling Patterns (stdlib)

### Structured Error Types

```go
// internal/pkg/errors/errors.go
type Error struct {
    Code    string `json:"code"`
    Message string `json:"message"`
    Cause   error  `json:"-"`
    Context map[string]interface{} `json:"context,omitempty"`
}

func (e *Error) Error() string {
    if e.Cause != nil {
        return fmt.Sprintf("%s: %v", e.Message, e.Cause)
    }
    return e.Message
}

func (e *Error) Unwrap() error {
    return e.Cause
}

// Common error constructors
func ValidationError(message string, context map[string]interface{}) *Error {
    return &Error{
        Code:    "VALIDATION_ERROR",
        Message: message,
        Context: context,
    }
}

func NotFoundError(resource string) *Error {
    return &Error{
        Code:    "NOT_FOUND",
        Message: fmt.Sprintf("%s not found", resource),
    }
}

func InternalError(cause error) *Error {
    return &Error{
        Code:    "INTERNAL_ERROR",
        Message: "An internal error occurred",
        Cause:   cause,
    }
}
```

### Error Middleware

```go
// internal/service/api/middleware/recovery.go
func Recovery(logger *slog.Logger) Middleware {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            defer func() {
                if err := recover(); err != nil {
                    // Log the panic with stack trace
                    logger.Error("Panic recovered",
                        "error", err,
                        "path", r.URL.Path,
                        "method", r.Method,
                        "stack", string(debug.Stack()),
                    )

                    // Return 500 error
                    if !isHeaderWritten(w) {
                        http.Error(w, "Internal server error", http.StatusInternalServerError)
                    }
                }
            }()

            next.ServeHTTP(w, r)
        })
    }
}

func isHeaderWritten(w http.ResponseWriter) bool {
    // Check if headers have been written
    if rw, ok := w.(*responseWriter); ok {
        return rw.written
    }
    return false
}
```

## Testing Strategy (stdlib testing)

### HTTP Handler Testing

```go
// internal/service/api/handlers/tracks_test.go
func TestTracksHandler_GetTracks(t *testing.T) {
    // Setup
    db := setupTestDB(t)
    defer db.Close()

    repo := postgres.NewTrackRepository(db, slog.Default())
    handler := &TracksHandler{
        trackRepo: repo,
        logger:    slog.Default(),
    }

    // Seed test data
    seedTracks(t, db, "test-server-1", 25)

    tests := []struct {
        name           string
        serverID       string
        page           string
        limit          string
        expectedStatus int
        expectedCount  int
    }{
        {
            name:           "successful pagination",
            serverID:       "test-server-1",
            page:           "0",
            limit:          "10",
            expectedStatus: http.StatusOK,
            expectedCount:  10,
        },
        {
            name:           "missing server_id",
            serverID:       "",
            expectedStatus: http.StatusBadRequest,
        },
        {
            name:           "invalid page number",
            serverID:       "test-server-1",
            page:           "-1",
            limit:          "10",
            expectedStatus: http.StatusOK,
            expectedCount:  10, // Should default to page 0
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Create request
            url := "/api/v1/tracks"
            if tt.serverID != "" || tt.page != "" || tt.limit != "" {
                params := make(url.Values)
                if tt.serverID != "" {
                    params.Set("server_id", tt.serverID)
                }
                if tt.page != "" {
                    params.Set("page", tt.page)
                }
                if tt.limit != "" {
                    params.Set("limit", tt.limit)
                }
                url += "?" + params.Encode()
            }

            req := httptest.NewRequest(http.MethodGet, url, nil)
            w := httptest.NewRecorder()

            // Execute
            handler.HandleTracks(w, req)

            // Assert
            assert.Equal(t, tt.expectedStatus, w.Code)

            if tt.expectedStatus == http.StatusOK {
                var response APIResponse
                err := json.NewDecoder(w.Body).Decode(&response)
                assert.NoError(t, err)
                assert.True(t, response.Success)

                tracks := response.Data.([]interface{})
                assert.Len(t, tracks, tt.expectedCount)
            }
        })
    }
}
```

### Integration Testing

```go
// tests/integration/api_test.go
func TestAPIIntegration(t *testing.T) {
    // Setup test server
    server := setupTestServer(t)
    defer server.Close()

    client := &http.Client{Timeout: 10 * time.Second}

    t.Run("complete track flow", func(t *testing.T) {
        // 1. Create a track via worker simulation
        track := createTestTrack(t, server.DB, "test-server")

        // 2. Fetch tracks via API
        resp, err := client.Get(server.URL + "/api/v1/tracks?server_id=test-server")
        require.NoError(t, err)
        defer resp.Body.Close()

        assert.Equal(t, http.StatusOK, resp.StatusCode)

        var apiResp APIResponse
        err = json.NewDecoder(resp.Body).Decode(&apiResp)
        require.NoError(t, err)

        assert.True(t, apiResp.Success)
        tracks := apiResp.Data.([]interface{})
        assert.Len(t, tracks, 1)

        // 3. Search for the track
        searchURL := fmt.Sprintf("%s/api/v1/search?server_id=test-server&q=%s",
            server.URL, url.QueryEscape(track.Title))

        resp, err = client.Get(searchURL)
        require.NoError(t, err)
        defer resp.Body.Close()

        assert.Equal(t, http.StatusOK, resp.StatusCode)
    })
}
```

## Production Deployment Patterns

### Build Script

```bash
#!/bin/bash
# scripts/build.sh

set -e

VERSION=${1:-"latest"}
BUILD_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)
GIT_COMMIT=$(git rev-parse --short HEAD)

echo "Building version: $VERSION"
echo "Build time: $BUILD_TIME"
echo "Git commit: $GIT_COMMIT"

# Build flags for production
BUILD_FLAGS="-ldflags=-X main.Version=$VERSION -X main.BuildTime=$BUILD_TIME -X main.GitCommit=$GIT_COMMIT -w -s"

# Build all services
echo "Building bot service..."
CGO_ENABLED=0 GOOS=linux go build $BUILD_FLAGS -o bin/bot ./cmd/bot

echo "Building worker service..."
CGO_ENABLED=0 GOOS=linux go build $BUILD_FLAGS -o bin/worker ./cmd/worker

echo "Building API service..."
CGO_ENABLED=0 GOOS=linux go build $BUILD_FLAGS -o bin/api ./cmd/api

echo "Build complete!"
```

### Migration System

```go
// internal/repository/postgres/migrations.go
type Migration struct {
    Version int
    Name    string
    SQL     string
}

var migrations = []Migration{
    {
        Version: 1,
        Name:    "create_servers_table",
        SQL: `
            CREATE TABLE IF NOT EXISTS servers (
                id VARCHAR(20) PRIMARY KEY,
                name VARCHAR(255) NOT NULL,
                configured_channel_id VARCHAR(20),
                settings JSONB DEFAULT '{}',
                created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
                updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
            );

            CREATE INDEX IF NOT EXISTS idx_servers_channel
            ON servers(configured_channel_id);
        `,
    },
    {
        Version: 2,
        Name:    "create_tracks_table",
        SQL: `
            CREATE TABLE IF NOT EXISTS tracks (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                server_id VARCHAR(20) NOT NULL REFERENCES servers(id) ON DELETE CASCADE,
                url TEXT NOT NULL,
                platform VARCHAR(50) NOT NULL,
                title VARCHAR(500),
                artist VARCHAR(500),
                duration INTEGER,
                thumbnail_url TEXT,
                discord_message_id VARCHAR(20) NOT NULL,
                discord_channel_id VARCHAR(20) NOT NULL,
                message_content TEXT,
                metadata JSONB DEFAULT '{}',
                extraction_status VARCHAR(20) DEFAULT 'pending',
                posted_at TIMESTAMP WITH TIME ZONE NOT NULL,
                created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
                updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

                UNIQUE(discord_message_id, url),
                CHECK (platform IN ('youtube', 'soundcloud', 'mixcloud', 'bandcamp', 'spotify', 'apple_music'))
            );

            CREATE INDEX IF NOT EXISTS idx_tracks_server_posted
            ON tracks(server_id, posted_at DESC);

            CREATE INDEX IF NOT EXISTS idx_tracks_platform
            ON tracks(platform);
        `,
    },
    {
        Version: 3,
        Name:    "add_fulltext_search",
        SQL: `
            -- Add search vector column
            ALTER TABLE tracks ADD COLUMN IF NOT EXISTS search_vector tsvector;

            -- Update existing records
            UPDATE tracks SET search_vector = to_tsvector('english',
                coalesce(title,'') || ' ' || coalesce(artist,''));

            -- Create index
            CREATE INDEX IF NOT EXISTS idx_tracks_search
            ON tracks USING GIN(search_vector);

            -- Create trigger for automatic updates
            CREATE OR REPLACE FUNCTION update_tracks_search_vector()
            RETURNS trigger AS $
            BEGIN
                NEW.search_vector := to_tsvector('english',
                    coalesce(NEW.title,'') || ' ' || coalesce(NEW.artist,''));
                RETURN NEW;
            END;
            $ LANGUAGE plpgsql;

            DROP TRIGGER IF EXISTS tracks_search_vector_update ON tracks;
            CREATE TRIGGER tracks_search_vector_update
                BEFORE INSERT OR UPDATE ON tracks
                FOR EACH ROW EXECUTE FUNCTION update_tracks_search_vector();
        `,
    },
}

func RunMigrations(db *sql.DB) error {
    // Create migrations table
    _, err := db.Exec(`
        CREATE TABLE IF NOT EXISTS migrations (
            version INTEGER PRIMARY KEY,
            name VARCHAR(255) NOT NULL,
            applied_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        )
    `)
    if err != nil {
        return fmt.Errorf("failed to create migrations table: %w", err)
    }

    // Get current version
    var currentVersion int
    err = db.QueryRow("SELECT COALESCE(MAX(version), 0) FROM migrations").Scan(&currentVersion)
    if err != nil {
        return fmt.Errorf("failed to get current version: %w", err)
    }

    // Apply pending migrations
    for _, migration := range migrations {
        if migration.Version <= currentVersion {
            continue
        }

        log.Printf("Applying migration %d: %s", migration.Version, migration.Name)

        tx, err := db.Begin()
        if err != nil {
            return fmt.Errorf("failed to begin transaction: %w", err)
        }

        if _, err := tx.Exec(migration.SQL); err != nil {
            tx.Rollback()
            return fmt.Errorf("failed to apply migration %d: %w", migration.Version, err)
        }

        if _, err := tx.Exec("INSERT INTO migrations (version, name) VALUES ($1, $2)",
            migration.Version, migration.Name); err != nil {
            tx.Rollback()
            return fmt.Errorf("failed to record migration %d: %w", migration.Version, err)
        }

        if err := tx.Commit(); err != nil {
            return fmt.Errorf("failed to commit migration %d: %w", migration.Version, err)
        }

        log.Printf("Migration %d applied successfully", migration.Version)
    }

    return nil
}
```

## Performance Benchmarks

### HTTP Handler Benchmarks

```go
// benchmarks/api_test.go
func BenchmarkTracksHandler(b *testing.B) {
    // Setup
    handler := setupBenchmarkHandler(b)

    b.Run("get_tracks", func(b *testing.B) {
        req := httptest.NewRequest("GET", "/api/v1/tracks?server_id=test&page=0&limit=20", nil)

        b.ResetTimer()
        b.ReportAllocs()

        for i := 0; i < b.N; i++ {
            w := httptest.NewRecorder()
            handler.HandleTracks(w, req)
        }
    })

    b.Run("search_tracks", func(b *testing.B) {
        req := httptest.NewRequest("GET", "/api/v1/search?server_id=test&q=test", nil)

        b.ResetTimer()
        b.ReportAllocs()

        for i := 0; i < b.N; i++ {
            w := httptest.NewRecorder()
            handler.HandleSearch(w, req)
        }
    })
}
```

## Documentation Strategy

### API Documentation

```go
// Generate OpenAPI spec from code
//go:generate swagger generate spec -o ./docs/swagger.json

// @title Discord Music Bot API
// @version 1.0
// @description A Discord bot that archives music links
// @host localhost:8080
// @BasePath /api/v1

// @tag.name tracks
// @tag.description Track management operations

// HandleTracks godoc
// @Summary Get tracks for a Discord server
// @Description Retrieve paginated list of music tracks for a specific Discord server
// @Tags tracks
// @Accept json
// @Produce json
// @Param server_id query string true "Discord server ID"
// @Param page query int false "Page number (default 0)"
// @Param limit query int false "Items per page (default 20, max 100)"
// @Success 200 {object} APIResponse{data=[]domain.Track}
// @Failure 400 {object} APIResponse{error=APIError}
// @Failure 500 {object} APIResponse{error=APIError}
// @Router /tracks [get]
func (h *TracksHandler) HandleTracks(w http.ResponseWriter, r *http.Request) {
    // Implementation...
}
```
